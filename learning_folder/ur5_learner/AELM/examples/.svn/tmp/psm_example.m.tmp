close all;
clear all;

%% load data
load('minjerk_data.mat');

numMotions = size(X,1);
numTimeSteps = t_end;
P = viaPoints;
minmax = [-1.2 0.2 0 1.2];

%% train DMPs
dim = 2;
numBasisFcts = 10;
tau = 10;
K = 5;
tau = 1;
K = 0.5;
tinyeval = 0;

dmps = cell(numMotions,1);
W = zeros(numMotions, numBasisFcts * dim);
D = cell(numMotions,1);
fprintf(['training DMPs for ' num2str(numMotions) ' motions']);
for m=1:numMotions
    % create and train DMP
    dmps{m} = MyDMP(dim);
    dmps{m}.tau = tau;
    dmps{m}.setK(K);
    dmps{m}.train(X{m}, tinyeval);
    
    % collect weights and generated trajectories
    W(m,:) = time2space(dmps{m}.weights);
    D{m} = dmps{m}.movgen(xstart, xgoal);
    D{m} = resample(D{m}, numTimeSteps);
    if mod(m,10) == 0
        fprintf('.');
    end
end
fprintf('done!\n');

plotMotionMap([time2space(X); time2space(D)], [P; P], minmax, 1/(numViaPointSteps+1));
drawnow;

%% prepare multimodal data for PSM
T = time2space(X);
%T = time2space(D); % use reproduced trajectories from DMPs
TWP = [T W P];

% split training and test set
ptrain = 0.5;
numTrain = round(ptrain * numMotions);
numTest = numMotions - numTrain;
r = randperm(numMotions);
idx_tr = r(1:numTrain);
idx_te = r(numTrain+1:end);
TWP_tr = TWP(idx_tr,:);
TWP_te = TWP(idx_te,:);


%% train PSM
modDims = [size(T,2) size(W,2) size(P,2)];
lspecs = {'class', 'ARBF'; 'hbdist', 0.1; ...
            'c', [ones(1,modDims(1))/modDims(1) ones(1,modDims(2))/modDims(2) ones(1,modDims(3))/modDims(3)]; ...
            'b', 1; 'regOut', [1e-3 1e-3 1e-3]; 'conv', 0};
% lspecs = {'class', 'AELM'; 'hidDim', 100; 'inpScale', [1/modDims(1) 1/modDims(2) 1/modDims(3)]; ...
%            'c', [ones(1,modDims(1))/modDims(1) ones(1,modDims(2))/modDims(2) ones(1,modDims(3))/modDims(3)]; ...
%            'g', [1/3 1/3 1/3]; 'regInp', [1e-3 1e-3 1e-3]; 'regOut', [1e-4 1e-4 1e-4]; 'conv', 1; 'batchSize', 10000};
        
fprintf('training PSM...');
cmd = ['psm = ' lspecs{1,2} '(modDims, lspecs);'];
eval(cmd);
psm.init(TWP_tr);
psm.train(TWP_tr, TWP_tr);
fprintf('done!\n');
disp(['hidDim = ' num2str(psm.hidDim)]);

disp('testing PSM...');
disp(' driving PSM with trajectories T, retrieve DMP params W and via points P');
psm.setDrivenMods(1);
WPhat = psm.apply(TWP);
What = WPhat(:,psm.modBeginEnd(2,1):psm.modBeginEnd(2,2));
Phat = WPhat(:,psm.modBeginEnd(3,1):psm.modBeginEnd(3,2));
EW = sqrt(sum((W - What).^2, 2))./modDims(2);
EP = sqrt(sum((P - Phat).^2, 2))./modDims(3);
disp(['  E_tr W: ' num2str(mean(EW(idx_tr))) ' +- ' num2str(std(EW(idx_tr)))]);
disp(['  E_te W: ' num2str(mean(EW(idx_te))) ' +- ' num2str(std(EW(idx_te)))]);
disp(['  E_tr P: ' num2str(mean(EP(idx_tr))) ' +- ' num2str(std(EP(idx_tr)))]);
disp(['  E_te P: ' num2str(mean(EP(idx_te))) ' +- ' num2str(std(EP(idx_te)))]);

disp(' driving PSM with DMP params W, retrieve trajectories T and via points P');
psm.setDrivenMods(2);
TPhat = psm.apply(TWP);
That = TPhat(:,psm.modBeginEnd(1,1):psm.modBeginEnd(1,2));
Phat = TPhat(:,psm.modBeginEnd(3,1):psm.modBeginEnd(3,2));
ET = sqrt(sum((T - That).^2, 2))./modDims(1);
EP = sqrt(sum((P - Phat).^2, 2))./modDims(3);
disp(['  E_tr T: ' num2str(mean(ET(idx_tr))) ' +- ' num2str(std(ET(idx_tr)))]);
disp(['  E_te T: ' num2str(mean(ET(idx_te))) ' +- ' num2str(std(ET(idx_te)))]);
disp(['  E_tr P: ' num2str(mean(EP(idx_tr))) ' +- ' num2str(std(EP(idx_tr)))]);
disp(['  E_te P: ' num2str(mean(EP(idx_te))) ' +- ' num2str(std(EP(idx_te)))]);

disp(' driving PSM with via points P, retrieve trajectories T and DMP params W');
psm.setDrivenMods(3);
TWhat = psm.apply(TWP);
That = TWhat(:,psm.modBeginEnd(1,1):psm.modBeginEnd(1,2));
What = TWhat(:,psm.modBeginEnd(2,1):psm.modBeginEnd(2,2));
ET = sqrt(sum((T - That).^2, 2))./modDims(1);
EW = sqrt(sum((W - What).^2, 2))./modDims(2);
disp(['  E_tr T: ' num2str(mean(ET(idx_tr))) ' +- ' num2str(std(ET(idx_tr)))]);
disp(['  E_te T: ' num2str(mean(ET(idx_te))) ' +- ' num2str(std(ET(idx_te)))]);
disp(['  E_tr W: ' num2str(mean(EW(idx_tr))) ' +- ' num2str(std(EW(idx_tr)))]);
disp(['  E_te W: ' num2str(mean(EW(idx_te))) ' +- ' num2str(std(EW(idx_te)))]);

disp('done!');



%%%%%%%%%%%%%%%%%% interactive testing %%%%%%%%%%%%%%%%%%%%%%%
t = T(1,:);
w = W(1,:);
p = P(1,:);
twp = [t w p];
psm.setDrivenMods([1 2 3]);
psm.conv = 0;

close all;
h = figure;
rotate3d on;
set(gcf, 'SelectionType', 'open');
stop = 0;
modus = 3;
modistr = {'trajectory', 'DMP params', 'embedding'};
disp(['Modus switched! PSM driven by ' modistr{modus}]);
while ~stop
    subplot(1,2,1);
    point = get(gca, 'CurrentPoint');
    button = get(gcf,'SelectionType');
    target = [point(1,1) point(1,2)];
    
    if strcmp(button, 'alt')
        modus = modus + 1;
        if modus > 3
            modus = 1;
        end
        disp(['Modus switched! PSM driven by ' modistr{modus}]);
        if target(1) < -1.2
            stop = 1;
        end
    elseif strcmp(get(rotate3d(h),'Enable'), 'on')
        if modus == 1
            [tmp idx] = knn(P,target,1);
            target = P(idx(1),:);
            t = T(idx(1),:);
        elseif modus == 2
            [tmp idx] = knn(P,target,1);
            target = P(idx(1),:);
            w = W(idx(1),:);
        elseif modus == 3
            p = target;
        end
    end
    set(gcf, 'SelectionType', 'open');

    clf(h);
    subplot(1,2,1);
    hold on; box on; grid on;
    daspect([1 1 1]);
    axis(minmax);
    plot(P(idx_tr,1), P(idx_tr,2), '.k');
    plot(P(idx_te,1), P(idx_te,2), 'ok');
    plot(p(1), p(2), '*m');
    plot(target(1), target(2), '*r');
    
    subplot(1,2,2);
    hold on; box on; grid on;
    daspect([1 1 1]);
    axis(minmax);
    tmp = space2time(t,dim);
    plot(tmp(:,1), tmp(:,2), '-k');
    dmps{1}.weights = space2time(w,dim);
    tmp = dmps{1}.movgen(xstart, xgoal);
    plot(tmp(:,1), tmp(:,2), '-b');
    plot(target(1), target(2), '*r');
    
    [twphat] = psm.apply([t w p]);
    t = twphat(psm.modBeginEnd(1,1):psm.modBeginEnd(1,2));
    w = twphat(psm.modBeginEnd(2,1):psm.modBeginEnd(2,2));
    p = twphat(psm.modBeginEnd(3,1):psm.modBeginEnd(3,2));
    
    drawnow;
end

%close(h);


