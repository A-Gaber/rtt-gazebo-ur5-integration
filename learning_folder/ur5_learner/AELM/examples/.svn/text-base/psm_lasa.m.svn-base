close all;
clear all;

%% load data
load('lasa_dmp_som.mat');


%% prepare multimodal data for PSM
T = time2space(T);
%T = time2space(D); % use reproduced trajectories from DMPs
TWP = [T W P];
%TWP = [time2space(S) WPrototypes PPrototypes];

% split training and test set
ptrain = 0.95;
numTrain = round(ptrain * numMotions);
numTest = numMotions - numTrain;
r = randperm(numMotions);
idx_tr = r(1:numTrain);
idx_te = r(numTrain+1:end);
TWP_tr = TWP(idx_tr,:);
TWP_te = TWP(idx_te,:);


%% train PSM
modDims = [size(T,2) size(W,2) size(P,2)];
lspecs = {'class', 'ARBF'; 'hbdist', 0.1; ...
            'c', [ones(1,modDims(1))/modDims(1) ones(1,modDims(2))/modDims(2) ones(1,modDims(3))/modDims(3)]; ...
            'b', 1; 'regOut', [1e-3 1e-3 1e-3]; 'conv', 1};
%lspecs = {'class', 'AELM'; 'hidDim', 200; 'inpScale', [1/modDims(1) 1/modDims(2) 1/modDims(3)]; ...
%            'g', [1/3 1/3 1/3]; 'regInp', 1e-3 * ones(1,3); 'regOut', 1e-4 * ones(1,3); ...
%            'sp', [0.2 10 5 100]; 'conv', 1; 'maxDX', 1e-2; 'maxSteps', 1000; 'batchSize', 10000};
        
fprintf('training PSM...');
cmd = ['psm = ' lspecs{1,2} '(modDims, lspecs);'];
eval(cmd);
psm.init(TWP_tr);
psm.train(TWP_tr, TWP_tr);
fprintf('done!\n');
disp(['hidDim = ' num2str(psm.hidDim)]);

disp('testing PSM...');
disp(' driving PSM with trajectories T, retrieve DMP params W and via embeddings P');
psm.setDrivenMods(1);
if isa(psm, 'AELM')
    psm.g = [2/3 1/6 1/6];
end
WPhat = psm.apply(TWP);
What = WPhat(:,psm.modBeginEnd(2,1):psm.modBeginEnd(2,2));
Phat = WPhat(:,psm.modBeginEnd(3,1):psm.modBeginEnd(3,2));
EW = sqrt(sum((W - What).^2, 2))./modDims(2);
EP = sqrt(sum((P - Phat).^2, 2))./modDims(3);
disp(['  E_tr W: ' num2str(mean(EW(idx_tr))) ' +- ' num2str(std(EW(idx_tr)))]);
disp(['  E_te W: ' num2str(mean(EW(idx_te))) ' +- ' num2str(std(EW(idx_te)))]);
disp(['  E_tr P: ' num2str(mean(EP(idx_tr))) ' +- ' num2str(std(EP(idx_tr)))]);
disp(['  E_te P: ' num2str(mean(EP(idx_te))) ' +- ' num2str(std(EP(idx_te)))]);

disp(' driving PSM with DMP params W, retrieve trajectories T and embeddings P');
psm.setDrivenMods(2);
if isa(psm, 'AELM')
    psm.g = [1/6 2/3 1/6];
end
TPhat = psm.apply(TWP);
That = TPhat(:,psm.modBeginEnd(1,1):psm.modBeginEnd(1,2));
Phat = TPhat(:,psm.modBeginEnd(3,1):psm.modBeginEnd(3,2));
ET = sqrt(sum((T - That).^2, 2))./modDims(1);
EP = sqrt(sum((P - Phat).^2, 2))./modDims(3);
disp(['  E_tr T: ' num2str(mean(ET(idx_tr))) ' +- ' num2str(std(ET(idx_tr)))]);
disp(['  E_te T: ' num2str(mean(ET(idx_te))) ' +- ' num2str(std(ET(idx_te)))]);
disp(['  E_tr P: ' num2str(mean(EP(idx_tr))) ' +- ' num2str(std(EP(idx_tr)))]);
disp(['  E_te P: ' num2str(mean(EP(idx_te))) ' +- ' num2str(std(EP(idx_te)))]);

disp(' driving PSM with embeddings P, retrieve trajectories T and DMP params W');
psm.setDrivenMods(3);
if isa(psm, 'AELM')
    psm.g = [1/6 1/6 2/3];
end
TWhat = psm.apply(TWP);
That = TWhat(:,psm.modBeginEnd(1,1):psm.modBeginEnd(1,2));
What = TWhat(:,psm.modBeginEnd(2,1):psm.modBeginEnd(2,2));
ET = sqrt(sum((T - That).^2, 2))./modDims(1);
EW = sqrt(sum((W - What).^2, 2))./modDims(2);
disp(['  E_tr T: ' num2str(mean(ET(idx_tr))) ' +- ' num2str(std(ET(idx_tr)))]);
disp(['  E_te T: ' num2str(mean(ET(idx_te))) ' +- ' num2str(std(ET(idx_te)))]);
disp(['  E_tr W: ' num2str(mean(EW(idx_tr))) ' +- ' num2str(std(EW(idx_tr)))]);
disp(['  E_te W: ' num2str(mean(EW(idx_te))) ' +- ' num2str(std(EW(idx_te)))]);

disp('done!');



%%%%%%%%%%%%%%%%%% interactive testing %%%%%%%%%%%%%%%%%%%%%%%
t = T(1,:);
w = W(1,:);
p = P(1,:);
twp = [t w p];
psm.setDrivenMods([1 2 3]);
psm.conv = 0;

close all;
h = figure;
rotate3d on;
set(gcf, 'SelectionType', 'open');
stop = 0;
modus = 3;
modistr = {'trajectory', 'DMP params', 'embedding'};
disp(['Modus switched! PSM driven by ' modistr{modus}]);
while ~stop
    subplot(1,2,1);
    point = get(gca, 'CurrentPoint');
    button = get(gcf,'SelectionType');
    target = [point(1,1) point(1,2)];
    
    if strcmp(button, 'alt')
        modus = modus + 1;
        if modus > 3
            modus = 1;
        end
        disp(['Modus switched! PSM driven by ' modistr{modus}]);
        if modus == 1
            if isa(psm, 'AELM')
                psm.g = [2/3 1/6 1/6];
            end
        elseif modus == 2
            if isa(psm, 'AELM')
                psm.g = [1/6 2/3 1/6];
            end
        elseif modus == 3
            if isa(psm, 'AELM')
                psm.g = [1/6 1/6 2/3];
            end
        end
        if target(1) < -1.2
            stop = 1;
        end
    elseif strcmp(get(rotate3d(h),'Enable'), 'on')
        if modus == 1
            [tmp idx] = knn(P,target,1);
            target = P(idx(1),:);
            t = T(idx(1),:);
        elseif modus == 2
            [tmp idx] = knn(P,target,1);
            target = P(idx(1),:);
            w = W(idx(1),:);
        elseif modus == 3
            p = target;
        end
    end
    set(gcf, 'SelectionType', 'open');

    clf(h);
    subplot(1,2,1);
    hold on; box on; grid on;
    daspect([1 1 1]);
    axis(minmax);
    plot(P(idx_tr,1), P(idx_tr,2), '.k');
    plot(P(idx_te,1), P(idx_te,2), 'ok');
    plot(p(1), p(2), '*m');
    plot(target(1), target(2), '*r');
    
    subplot(1,2,2);
    hold on; box on; grid on;
    daspect([1 1 1]);
    axis(minmax);
    tmp = space2time(t,dim);
    plot(tmp(:,1), tmp(:,2), '-k');
    dmps{1}.weights = space2time(w,dim);
    tmp = dmps{1}.movgen([-1 0], [0 0]);
    plot(tmp(:,1), tmp(:,2), '-b');
    
    [twphat] = psm.apply([t w p]);
    t = twphat(psm.modBeginEnd(1,1):psm.modBeginEnd(1,2));
    w = twphat(psm.modBeginEnd(2,1):psm.modBeginEnd(2,2));
    p = twphat(psm.modBeginEnd(3,1):psm.modBeginEnd(3,2));
    
    drawnow;
end

%close(h);

